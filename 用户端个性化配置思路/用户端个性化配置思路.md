# 用户端个性化配置方案思路整理

## 背景
随着用户数量逐渐增加，出现了一些差异化需求，从技术实现上提前进行升级改造的通用方案整理，涉及到`微信小程序用户端`、`H5用户端`。作为技术开发团队，“友好的产品体验” 和 “稳定的系统服务” 是最基本的执行原则，因此还需要考虑差异化处理后，加载、渲染性能和感知体验几大维度的优化。

已知的差异化需求点如下:
- 商户品牌标识差异;
- 不同色彩风格的皮肤选项
- 入口页面各模块的显示、隐藏、排序；
- 产品详情各模块的显示、隐藏、排序；

## 渲染结构
- 视图层：也就是view部分，负责启用html、wxml来渲染不同的页面；
- 逻辑层：执行JS代码，可以控制视图层的交互及显示逻辑；

![前端渲染结构](https://tzvuf.github.io/用户端个性化配置思路/01_前端渲染结构.gif)

应用启动阶段，1.下载静态资源文件 => 2.加载解析静态资源 => 3.初始页面结构，样式、数据 => 4.渲染页面。

页面的个性化配置需要在逻辑层预先处理，视图层处理的是页面差异化的渲染，页面的数据传输都是有延时的，逻辑层和视图层间数据通信是异步行为，但是个性化配置需要在渲染前页面步骤前完成，避免显示上的视觉切换跳动。

## 组件模块差异化处理
多个页面控件之间位置不固定，支持随时随地灵活配置，首页和产品详情页面存在此类需求。

当页面主体可被划分为若干个业务组件（如搜索框、导航栏、产品模块等），这些业务组件的顺序是不固定的，或者是某些模块显示，某些隐藏。我们不可能针对多种顺序可能性提供多套实现，这就需要用到自定义模板的调度处理。

实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。
注: 微信小程序的组件设计方式没有React灵活, 预计是使用小程序官方提供的`template`内进行组件调度判断, 但大致的思路是相同的。
`   
    <!-- 后台下发的顺序配置 -->

    const index_components_config =  [
        { compKey: 'Logo', index: 0, is_show: false },
        { compKey: 'Banner', index: 1, is_show: true },
        { compKey: 'NavBar', index: 2, is_show: true, query_mode:['CARMODEL_QUERY,VIN_QUERY']  },
        { compKey: 'SearchBar', index: 3, is_show: true  },
        { compKey: 'SelectCagegory', index: 4, is_show: true  },
    ];

    // index.js
    class index extends Component {
        state = {
            index_components_config: []
        };
        componentDidMount() {
            // 获取配置
            dispatch({
                type: 'global/fetchIndexComponentsConfig', 
                payload: index_components_config 
            });
        }
    }

    <!-- 配置渲染组件  -->
    const RenderComponent = (config) => {
        const { compkey, query_mode } = config;
        return (
            <>
                {compkey === 'logo' && <Logo />}
                {compkey === 'Banner' && <Banner />}
                {compkey === 'NavBar' && <NavBar queryMode={query_mode} />}
                {compkey === 'SearchBar' && <SearchBar />}
                {compkey === 'SelectCagegory' && <SelectCagegory />}
            </>
        );
    };

    <!-- 首页视图 遍历处理页面显示 -->
    {
        index_components_config
            .filter(v => v.isShow) // 过滤显示内容
            .map(v => {
                return <RenderComponent key={item.compkey} config={v}>
            })
    }

`

![组件模块差异化处理](https://tzvuf.github.io/用户端个性化配置思路/02_组件模块差异化处理.png)

## 色彩差异化处理[h5]
流程: 入口获取后台返回的皮肤配置 => 缓存皮肤配置 => 每个页面配置多个皮肤文件动态导入,非皮肤元素样式设置通用文件 => 页面className不做任何调整和判断,自动匹配皮肤设置

`
    
    <!-- 入口处理 后台返回皮肤配置为 red, 存储配置, 已有存储相同的皮肤配置,不做处理 -->
    if(getLocal !== 'red' ) && setLocal('skinConfig', 'red');

    <!-- 皮肤配置文件 skin-red.less -->
    @skin-color: #cc0000;
    @skin-color-light: #ebe5e5;
    @skin-color-15: rgba(250,0,0, .15);

    <!-- 皮肤配置文件 skin-default.less -->
    @skin-color: #1a82d2;
    @skin-color-light: #D4E7FA;
    @skin-color-15: rgba(26,130,210, .15);

    <!-- index.skin.red.less -->
    @import './index.less'; // 页面通用样式
    @import '../../assets/css/skin-red.less'; // 皮肤变量
    .switchCategory {
        .badge {
            background-color: @skin-color; // 此处 @skin-color为红色
        }
    }

    <!-- 调用页面 顶部文件路径名适配 -->
    <!-- 路径名规范 index.skin.default.less | index.skin.red.less | index.skin.blue.less -->
    conar skinName = getLocal('skinConfig');
    const styles = require('./index.skin.' + skinName + '.less');

    <!-- 因为适配的是路径名称, 变量名未作变化, 使用时上不需要做其他判断 -->
    const Component = () => {
        <div className={styles.switchCategory}>
            这里的颜色会跟随顶部styles引入的配置进行变化
        </div>
    }

`


## 色彩差异化处理[微信小程序]
因为小程序不支持动态导入css文件,不可采用与h5相同的皮肤方案, 会比h5的实现繁琐一些, 需要在每个页面调用class的地方做变量处理
`

    <!-- 入口处理 后台返回皮肤配置为 red -->
    App({
        onLaunch: function (props) {
            this.globalData.skin = 'red';
        }
    })

    <!-- 小程序支持css3的变量新特性 在Page下设置全局变量 -->
    page{
        --skin-default: #1A82D2;
        --skin-red: red;
        --skin-green: green;
    }

    <!-- 页面样式 -->
    .custom-placehoder-default {
        color: var(--skin-default)
    }
    .custom-placehoder-red {
        color: var(--skin-red)
    }

    <!-- 页面调用 -->
    const app = getApp();
    Page({
        data: {
            skin: app.globalData.skin
        }
    })
    <input placeholder-class="{{'custom-placehoder-' + skin}}" />

`